package com.lolita.plugin

import com.lolita.annotations.ParameterDebug
import com.lolita.annotations.TimingDebug
import javassist.*
import javassist.bytecode.CodeAttribute
import javassist.bytecode.LocalVariableAttribute
import javassist.bytecode.MethodInfo
/**
 * ByteCodeWeaver
 */
public class ByteCodeWeaver {

    private static ClassPool pool ;
    private boolean global = false;

    public ByteCodeWeaver() {
    }

    /**
     * Begin to weave class under certain dir
     * @param path
     */
    public void weave(LolitaExtension lolitaExtension, ArrayList<String> androidClassPaths, String path) {
        if(lolitaExtension.on.equalsIgnoreCase("false")) {
            return;
        }
        global = lolitaExtension.global.equalsIgnoreCase("true");
        println "weave.global " + global;
        pool = new ClassPool(true);
        pool.insertClassPath(path)
        for(String item: androidClassPaths){
            println("Begin to appendClassPath = " + item)
            pool.insertClassPath(new JarClassPath(item))
        }
        pool.importPackage("android.util.Log");
        pool.importPackage("android.os.Looper");
        pool.importPackage("com.lolita.annotations.BlockManager");

        File dir = new File(path)
        int indexOfPackage = path.length() + 1;
        if (dir.isDirectory()) {
            dir.eachFileRecurse { File file ->
                String filePath = file.absolutePath
                if (isWeavableClass(filePath)) {

                    int end = filePath.length() - 6 // .class = 6
                    String className = filePath.substring(indexOfPackage, end).replace(File.separator, '.')
                    CtClass clazz = pool.getCtClass(className)

                    if (clazz.isFrozen()) {
                        clazz.defrost()
                    }
                    boolean timeDebugClass = false;
                    boolean parameterDebugClass = false;
                    boolean weaved = false;
                    if(clazz.hasAnnotation(TimingDebug.class)) {
                        timeDebugClass = true;
                    }
                    if(clazz.hasAnnotation(ParameterDebug.class)) {
                        parameterDebugClass = true;
                    }
                    if(global) {
                        timeDebugClass = true;
                    }
                    CtMethod[] methods = clazz.getDeclaredMethods();
                    for (CtMethod method : methods) {
                        boolean emptyMethod = method.isEmpty()
                        boolean isNativeMethod = Modifier.isNative(method.getModifiers());
                        if (!emptyMethod && !isNativeMethod) {
                            if (method.hasAnnotation(ParameterDebug.class) || parameterDebugClass) {
                                weaveParameterDebugMethod(clazz, method)
                                weaved = true
                            }
                            if (method.hasAnnotation(TimingDebug.class) || timeDebugClass) {
                                weaveTimingDebugMethod(clazz, method)
                                weaved = true
                            }
                        }
                    }
                    CtConstructor[] constructors = clazz.getDeclaredConstructors();
                    for(CtConstructor constructor: constructors){
                        boolean emptyMethod = constructor.isEmpty()
                        if (!emptyMethod) {
                            if (constructor.hasAnnotation(ParameterDebug.class) || parameterDebugClass) {
                                weaveParameterDebugMethod(clazz, constructor)
                                weaved = true
                            }
                            if (constructor.hasAnnotation(TimingDebug.class) || timeDebugClass) {
                                weaveTimingDebugMethod(clazz, constructor)
                                weaved = true
                            }
                        }
                    }
                    if(weaved) {
                        clazz.writeFile(path)
                        clazz.detach()
                    }
                }
            }
        }
    }


    /**
     * Class generated by Android Build System won't be weave, such as R.class, BuildConfig.class
     * @param filePath
     * @return
     */
    public boolean isWeavableClass(String filePath){
        return filePath.endsWith(".class") && !filePath.contains('R$') && !filePath.contains('R.class') && !filePath.contains("BuildConfig.class");
    }

    /**
     * Weave codes about method parameter into certain method
     * @param clazz
     * @param method
     */
    public void weaveParameterDebugMethod(CtClass clazz, CtBehavior method) {

        String[] params = getMethodParameterNames(method)
        StringBuilder parameterDetail = new StringBuilder("\"");
        parameterDetail.append("ParameaterDebug > ").append(method.getName()).append("[");
        for (int i = 0; i < params.length; i++) {
            if (i != 0) {
                parameterDetail.append("\"")
                parameterDetail.append(", ")
            }
            parameterDetail.append(params[i] + " = \" + " + "\$" + (i + 1));
            parameterDetail.append(" + ");
            if(i == params.length - 1) {
                parameterDetail.append("\"");
            }
        }
        parameterDetail.append("]\"");
        println "params = " + Arrays.toString(params)
        String tag = clazz.simpleName;
        String newCodes = "Log.i(\"" + tag + "\"," +
                parameterDetail.toString() +
                ");"
        method.insertBefore(newCodes)
    }

    /**
     * Weave codes about timing the method into method
     * @param clazz
     * @param method
     */
    public void weaveTimingDebugMethod(CtClass clazz, CtBehavior method) {
        method.addLocalVariable("startMs", CtClass.longType);
        try{
            method.insertBefore("startMs = System.currentTimeMillis();");
        }catch (Exception e) {
            println "insert before fail " + method.getLongName();
        }
        String line2 = "final long endMs = System.currentTimeMillis();";
        String line3 = "boolean mainThread = Looper.myLooper() == Looper.getMainLooper();"
        String line4 = "final long costMs = endMs - startMs;"
        String line5 = "if(mainThread && costMs >= 20)" +
                "Log.i(\"TimingDebug\"," + "\"TimingDebug > " + method.getName() + "[costed time in ms : \" + costMs "+ " + \"]\");"
        String line6 = "if(mainThread && costMs >= 20) BlockManager.addMethodBlockDetail(\""+ method.getLongName() +"\", (int)costMs);"
        String insertCode = line2 + line3 + line4 + line5 + line6;
        try{
            method.insertAfter(insertCode);
        }catch (Exception e) {
            println "insertAfter fail"+ method.getLongName();
        }
    }



    /**
     * Get Parmeter Names Of Certain Method
     * @param method
     * @return
     * @throws Exception
     */
    public String[] getMethodParameterNames(CtBehavior method) throws Exception {

        CtClass cc = method.getDeclaringClass();
        println "getDeclaringClass cc " + cc.getName();
        pool.insertClassPath(new ClassClassPath(cc.getClass()));

        CtClass[] parameterCtClasses = new CtClass[method.getParameterTypes().length];
        for (int i = 0; i < parameterCtClasses.length; i++)
            parameterCtClasses[i] = method.getParameterTypes()[i];
        String[] parameterNames = new String[parameterCtClasses.length];
        MethodInfo methodInfo = method.getMethodInfo();
        CodeAttribute codeAttribute = methodInfo.getCodeAttribute();
        LocalVariableAttribute attr = (LocalVariableAttribute) codeAttribute.getAttribute(LocalVariableAttribute.tag);
        int pos = Modifier.isStatic(method.getModifiers()) ? 0 : 1;
        for (int i = 0; i < parameterNames.length; i++)
            parameterNames[i] = attr.variableName(i + pos);
        return parameterNames;
    }

}